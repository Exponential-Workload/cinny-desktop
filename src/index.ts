import {
  app,
  BrowserWindow,
  ipcMain,
  shell,
  protocol,
  net,
  session as sessionImport,
} from 'electron';
// @ts-ignore
import randomport from 'random-port';
import chalk from 'chalk';
import createApp from './express';
import path from 'path';
import { copyFileSync, readFileSync, writeFileSync } from 'fs';
import { z } from 'zod';
import semver from 'semver';
import { execSync } from 'child_process';

app.setAppUserModelId('Cinny Desktop');
app.setName('Cinny Desktop');

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) app.quit();

const pkg = JSON.parse(
  readFileSync(path.resolve(__dirname, 'package.json'), 'utf-8'),
);
const v = pkg.version;
const prefix = `${chalk.grey('[')}${chalk.green(`Cinny Host ${v}`)}${chalk.grey(
  ']',
)}`;

if (
  process.argv.includes('--license') ||
  process.argv.includes('--legal') ||
  process.argv.includes('-l')
) {
  console.log(`
    cinny-desktop
    Copyright (C) 2023  Expo

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as
    published by the Free Software Foundation, either version 3 of the
    License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
`);
  process.exit(0);
} else if (process.argv.includes('--version') || process.argv.includes('-v')) {
  console.log(v);
  process.exit(0);
} else if (process.argv.includes('--setup-desktop')) {
  switch (process.platform) {
    case 'linux': {
      const home = app.getPath('home');
      const localShare =
        process.env.LOCAL_SHARE ?? process.env.USER === 'root'
          ? '/usr/share'
          : path.join(home, '.local/share');
      writeFileSync(
        path.join(localShare, 'applications/cinny.desktop'),
        `[Desktop Entry]
Version=1.0
Name=Cinny Desktop
Comment=A Matrix Client
GenericName=Messenger
Type=Application
Terminal=false
Icon=moe.expo.cinny
StartupWMClass=Cinny Desktop
Categories=Network;InstantMessaging;Chat;IRCClient
Exec=${JSON.stringify(app.getPath('exe'))} %u
`,
      );
      const icons = path.join(localShare, `icons`);
      const locolorApp = path.join(icons, `locolor/512x512/apps`);
      execSync(`mkdir -p ${JSON.stringify(locolorApp)}`);
      copyFileSync(
        __dirname + '/static/icons/cinny-512.png',
        path.join(icons, 'moe.expo.cinny.png'),
      );
      copyFileSync(
        __dirname + '/static/icons/cinny-512.png',
        path.join(locolorApp, 'moe.expo.cinny.png'),
      );
      console.log(prefix, 'Setup .desktop file successfully!');
      break;
    }

    default:
      throw new Error(
        `Platform ${process.platform} currently does not support --setup-desktop. Refer to the readme.`,
      );
  }
}
const priv = [
  {
    scheme: 'cinny',
    privileges: {
      bypassCSP: true,
      secure: true,
      standard: true,
      supportFetchAPI: true,
    },
  },
];
protocol.registerSchemesAsPrivileged(priv);

const cfgPath = path.join(app.getPath('userData'), '.cfg');
let cfg = {
  apps: [] as {
    userid: string;
    pfp: string;
    id: number | null;
  }[],
  latestApp: null as number | null,
};
let f = '';
try {
  f = readFileSync(cfgPath, 'utf-8');
  cfg = {
    ...cfg,
    ...JSON.parse(f),
  };
} catch (error) {}
const saveCfg = () => {
  const f2 = JSON.stringify(cfg);
  if (f2 !== f) {
    writeFileSync(cfgPath, f2);
    f = f2;
  }
};

const createWindow = (): void => {
  if (process.env.USER === 'root' || process.env.POSTINSTALL) process.exit(0);
  saveCfg();
  // Create the browser window.
  const partition = 'persist:app';
  const session = sessionImport.fromPartition(partition);
  try {
    if (typeof session.protocol.registerSchemesAsPrivileged === 'function')
      session.protocol.registerSchemesAsPrivileged(priv);
  } catch (error) {
    console.warn(prefix, 'Got error while trying to privelege schema', error);
  }
  const faviconPath = path.resolve(__dirname, 'static', 'favicon.png');
  const mainWindow = new BrowserWindow({
    height: 600,
    width: 959,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      partition,
      session,
    },
    icon: faviconPath,
    darkTheme: true,
    minHeight: 400,
    minWidth: 400,
    title: 'Cinny Desktop',
    backgroundColor: '#1a1a1a',
    hasShadow: false,
    roundedCorners: true,
    // if you want to handle your own taskbar:
    // transparent: true,
    // frame: false,
  });
  // load the loading page
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
  // config the window
  try {
    mainWindow.setAppDetails({
      appId: 'Cinny Desktop',
      appIconPath: `${faviconPath}`,
    });
  } catch (error) {}
  // make new tabs open in user browser
  const registerOpenHandler = (window: BrowserWindow) =>
    window.webContents.setWindowOpenHandler(h => {
      shell.openExternal(h.url);
      return {
        action: 'deny',
      };
    });
  registerOpenHandler(mainWindow);
  mainWindow.setMenuBarVisibility(false);
  console.log(`${prefix} Searching for port & binding to it...`);
  const expressApp = createApp();
  randomport(
    {
      from: 1024,
      to: 42070, // (not 42069 to allow 42069 as an option)
    },
    (p: number) =>
      expressApp.listen(p, '127.0.0.1', () => {
        console.log(
          `${prefix} Listening on http://127.0.0.1:%d/ - Loading page`,
          p,
        );
        session.protocol.handle('cinny', request => {
          if (request.url.startsWith('cinny://app-create')) {
            const id = cfg.apps.length === 0 ? null : cfg.apps.length - 1;
            return new Response('', {
              headers: {
                Location: `cinny://app${id === null ? '' : '-'}${
                  id === null ? '' : id
                }`,
              },
              status: 302,
            });
          }
          return net.fetch(
            `http://127.0.0.1:${p}/${request.url.replace(
              /cinny:\/\/app(-[0-9]+)?\//,
              '',
            )}`,
          );
        });
        mainWindow.loadURL(
          `cinny://app${
            cfg.apps.find(v => v.id === cfg.latestApp)?.id
              ? `-${cfg.latestApp}`
              : ''
          }/`,
        );
        (async () => {
          console.log(`${prefix} Checking for updates...`);
          const updCheckRes = z
            .object({
              name: z.string(),
              tag_name: z.string(),
              target_commitish: z.string(),
              draft: z.boolean(),
              prerelease: z.boolean(),
            })
            .parse(
              await fetch(
                'https://api.github.com/repos/Exponential-Workload/cinny-desktop/releases/latest',
              ).then(v => v.json()),
            );
          console.log(
            `${prefix} Found Version ${updCheckRes.name} (current is ${v})`,
          );
          const currentSemver = semver.parse(v);
          const newSemver = semver.parse(updCheckRes.name);
          if (newSemver.compare(currentSemver) === 1) {
            const bw = new BrowserWindow({
              height: 400,
              width: 400,
              webPreferences: {
                preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
                session,
                partition,
              },
              icon: faviconPath,
              darkTheme: true,
              minHeight: 400,
              minWidth: 400,
              maxHeight: 500,
              maxWidth: 500,
              title: 'Cinny Desktop - Update Checker',
              backgroundColor: '#1a1a1a',
              hasShadow: false,
              roundedCorners: true,
            });
            bw.setMenuBarVisibility(false);
            registerOpenHandler(bw);
            await bw.loadURL(
              `cinny://app/update-notif?old=${encodeURIComponent(
                currentSemver.version,
              )}&new=${encodeURIComponent(newSemver.version)}`,
            );
          }
        })().catch(e =>
          console.error(`${prefix} Error during update check:`, e),
        );
      }),
  );
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') app.quit();
});

app.on('ready', () => {
  // 2nd arg to handle can be asynchronous!
  ipcMain.handle(
    'greet',
    (event, name?: string) =>
      `Hello from Electron Main Process, ${name ?? 'User'}!`,
  );
  ipcMain.handle('close-window', event => {
    event.sender.close();
  });
  ipcMain.handle('close-app', event => {
    app.quit();
  });
  ipcMain.handle(
    'update-app',
    (event, url: string, pfp: string | undefined, userid: string) => {
      let appId = Number(new URL(url).hostname.split('-')[1] ?? -1) as
        | number
        | null;
      if (appId < 0) appId = null;
      if (!pfp) pfp = cfg.apps.find(v => v.id === appId)?.pfp;
      cfg.apps = cfg.apps.filter(v => v.id !== appId);
      cfg.apps.unshift({
        id: appId,
        pfp,
        userid,
      });
      cfg.latestApp = appId;
      saveCfg();
      return cfg;
    },
  );
  ipcMain.handle('del-app', (event, url: string) => {
    let appId = Number(new URL(url).hostname.split('-')[1] ?? -1) as
      | number
      | null;
    if (appId < 0) appId = null;
    cfg.apps = cfg.apps.filter(v => v.id !== appId);
    saveCfg();
    return cfg;
  });
  ipcMain.handle('get-cfg', () => cfg);
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

process.on('exit', () => {
  app.quit();
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
